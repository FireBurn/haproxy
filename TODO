* x-forwarded-for
* implémenter l'option "log global" au niveau proxy pour utiliser les logs
  globaux.
* matching case-insensitive
* implémenter outgoing addr
* loguer t_cnx, t_data, t_total
+ factoriser la fonction de log (send_log = send_syslog+warning+alert)
+ désactivation du keep-alive (suppression des ^Connection: et ajout des Connection: close)
  -> 4 lignes (2 del, 2 add) suffisent.
+ ne pas loguer certaines adresses IP sources
  -> pour les health-checks uniquement -> pas de log pour les requêtes
     vides (option dontlognull)
- mesurer le tps consommé entre deux select, et fournir la conso CPU :
  %cpu = 100 * (tpreselect(n+1)-tpostselect(n)) / (tpreselect(n+1)-tpreselect(n))
- implémenter limitation fd dans la conf : setrlimit(RLIMIT_NOFILE, ...)
- implémenter core/no-core dans la conf : setrlimit(RLIMIT_CORE, ...)
- optimiser les regex pour accélérer les matches :
  - compter les matches
  - si match(n) & ([n].cpt > [n-1].cpt) & ([n].action == [n-1].action), swap(n,n-1)
  - régulièrement, diviser tous les compteurs (lors d'un dépassement par exemple)
- filtrage sur l'adresse IP source, et stocker le pointeur sur la dernière regex
  matchée dans la "session" pour accélérer les regex.

+ handle parametrable HTTP health-checks replies
- differentiate http headers and http uris
- support environment variables in config file
- support keep-alive
- support SSL

===================== demandes ==========================
ok> 1) écoute sur une plage de ports :
ok>   listen XXX 1.2.3.4:21000-21060
ok> 
ok> 2) écoutes multiples :
ok>   listen XXX 1.2.3.4:21000
ok>   bind 2.3.4.5:21001
ok>   bind 2.3.4.5:21000-21060
ok> 
ok> => on en arrive à ceci :
ok> 
ok> listen XXX [ address:port ]
ok>    bind addr:plage-port[,[addr:]plage-port]*
ok>    bind ...
ok>    ...
ok> 
ok>    => proxy->listen_fd et proxy->listen_addr doivent être
ok> 	  mis dans des listes
ok>    => OK pour listen, implémenter le BIND.
ok> 
ok> 3) reconnexion sur le même port sur le serveur :
ok> 
ok>    server XXX 1.2.3.4[:port]
ok>    si <port> n'est pas spécifié, on utilise le même port que celui qui a reçu
ok>    la connexion. Dans ce cas, il faut pouvoir forcer le port du health-check
ok>    par un nouveau parametre "port".
ok> 
ok> => ça permet les forwardings de plages :
ok> 
ok> listen XXX
ok>    bind 1.2.3.4:10000-11000
ok>    server 1.2.3.5
ok> 
4) paramètres par défaut :
   créer une section "defaults" qui précise les paramètres par défaut pour les
   sections suivantes, concernant les paramètres suivants :
     ok- les logs
     ok- les modes (tcp/http)
     ok- le balancing (round-robin/source)
     ok- les time-outs
     ok- maxconn
     ok- redisp
     ok- les options
     ok- le retry
     ok- les checks
     ok- les cookies/captures
       - les options des serveurs ?
       - les filtres et regex ?

5) implémenter "balance source" pour faire un hash sur la source.
   permettre de spécifier un masque sur lequel s'applique le hachage,
   ainsi qu'une option pour hacher en fonction de l'adresse dans le
   champ "x-forwarded-for". Problème pour le support des pannes: ce
   type de hash est utile là où la persistence par cookie ne peut pas
   s'appliquer, donc comment faire pour assurer un maximum de persistence
   en cas de panne ?

6) possibilité d'un process séparé par listen :
   listen XXX
      fork [ group_id ]

   le fait de spécifier group_id fera que toutes les instances utilisant le
   même identifiant de groupe seront gérées par un même processus.

   -> plus souple et plus compréhensible de faire des sections par processus,
      ce qui résoud également le cas ci-dessous. Ex:
   process_group X
      nbproc X
      uid X
      chroot X
      listen ...

7) gérer un chroot/uid/gid différents par process :
   (mais résolu par l'alternative du 6 ci-dessus)
   listen XXX
      chroot /truc
      uid 123
      gid 456

8) beaucoup de paramètres pourraient être spécifiques aux serveurs et non
   aux instances. Exemples :
   - adresse IP source pour atteindre le serveur
   - méthode de health-check (proto, port, ...)
   - poids
   - alerte en cas de disparition
   - le nombre max de sessions à lui envoyer

ok> 9) ajouter des paramètres optionnels à l'option "httpchk" permettant
ok>    de forcer la méthode, la version HTTP et des headers.
ok>    ex: option httpchk        -> OPTIONS / HTTP/1.0
ok> 	   option httpchk /test  -> OPTIONS /test HTTP/1.0
ok> 	   option httpchk HEAD / HTTP/1.0\nHost:\ www   -> tel quel

Todo for 1.1
============
* "no more server" alert
* config check
- anti-flapping

Todo for 1.2
============
- direct <server> <regex> <match>
- new config syntax allowing braces or '\' to be able to shorten lines
- insert/learn/check/log unique request ID, and add the ability
  to block bad responses.
- IPv6 :
  * listen [ip4.ip4.ip4.ip4]:port[-port]
  * listen [ip6::...ip6]/port[-port]
  server xxx ipv4 | ipv4: | ipv4:port[-port] | ipv6/ | ipv6/port[-port]
- appcookie
- weighted round robin + balance source
- option to shutdown(listen_sock) when max connections reached
